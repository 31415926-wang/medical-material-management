

  
  项目进度：

  1.登录页面：校验图标(完成)、记住密码（完成）
  2.拼图验证、登录功能：替换总接口（完成）、api（完成）、访问不了接口（完成）、拼图（完成）
  3.静态菜单、命名页面：（完成）
  4.用户、菜单、角色、部门管理：（顶部）新增 查询 列控制 导出 、（中部）表格数据 改删设三按钮、（底部）分页。（完成）
  5.校验问题（完成）
  6.角色管理(完成)、用户管理（完成）、菜单权限 (完成)
  7.物资资料、物资来源、物资去处、物资类别	（完成）
  8.发放记录、入库记录
  9.首页\库存情况
  10.健康中心

  拓展：动态路由、按钮权限、国际化、微前端、大屏逻辑
  大文件上传、

 


  视频笔记：

 
  # 一、vue2组件通信方式

    **props:**可以实现父子组件、子父组件、甚至兄弟组件通信

    **自定义事件**:可以实现子父组件通信

    **全局事件总线$bus**:可以实现任意组件通信

    **pubsub:**发布订阅模式实现任意组件通信

    **vuex**:集中式状态管理容器，实现任意组件通信

    **ref**:父组件获取子组件实例VC,获取子组件的响应式数据以及方法

    **slot:**插槽(默认插槽、具名插槽、作用域插槽)实现父子组件通信........



  # 二、vue3组件通信方式


  - 1.props

    在vue3中我们可以通过defineProps获取父组件传递的数据。且在组件内部不需要引入defineProps方法可以直接使用！
  
    代码：

      <Child info="我爱祖国" :money="money"></Child>
        
    * 写法1 
      <script setup lang="ts">
        let props = defineProps({    
          info:{
            type:String,//接受的数据类型
            default:'默认参数',//接受默认数据
          },
          money:{
            type:Number,
            default:0
            }
        })
        </script>

    * 写法2 
  
       let props = defineProps(["info",'money']);
    

    注意： 1.props是只读的(只能读取，不能修改)
          2.注意不要使用解构的方式获取数据：const { info } = props;
          3.defineProps(['xx'])可以不接收返回的值，使用时，页面调用可以直接使用变量即可，无需. ，但是js中想要调props的值,则需接收。（特殊）



  - 2.自定义事件

    在vue框架中事件分为两种:一种是原生的DOM事件，另外一种自定义事件。
    （原生DOM事件可以让用户与网页进行交互， 自定义事件可以实现子给父传递数据）

    - 原生DOM事件：

      <pre @click="handler">
            我是祖国的老花骨朵
      </pre>

      当前代码给pre标签绑定原生DOM事件点击事件,默认会给事件回调注入event事件对象。当然点击事件想注入多个参数可以按照下图操作。但是切记注入的事件对象务必叫做$event.
  
      <div @click="handler1(1,2,3,$event)">我要传递多个参数</div>
  

    注意区分事件挂载的情况：
       1.挂载在原生标签上，都为原生事件
       2.挂载在组件上：
          在vue3中，组件上的事件click等等，只要子组件没有接收都是原生DOM事件。
          在vue2中，在组件标签的事件需要通过native修饰符才能变为原生DOM事件，否则都是自定义事件。


    - 自定义DOM事件：

      <template>
          <h1>我是父组件</h1>
          <Event2  @xxx="handler3"></Event2>
      </template>
      
      <template>
          <h1>我是子组件Event2</h1>
          <button @click="handler" >点击我触发xxx自定义事件</button>
      </template>

      <script setup lang="ts">
        let $emit = defineEmits(["xxx"]);
        const handler = () => {
           $emit("xxx", "法拉利", "茅台");
      };
      </script>
   
      defineEmits方法是vue3提供的方法,不需要引入直接使用，此方执行会'返回一个方法'用于触发自定义事件。
  
      defineEmits方法触发后，如何用参数通讯：

      $emit('beforeSubmit',()=>{ })



### 1.3全局事件总线

  全局事件总线可以实现任意组件通信，在vue2中可以根据VM与VC关系推出全局事件总线。

  但是在vue3中没有Vue构造函数，也就没有Vue.prototype.以及组合式API写法没有this，

  那么在Vue3想实现全局事件的总线功能就有点不现实啦，如果想在Vue3中使用全局事件总线功能

  可以使用插件mitt实现。


  使用：

  1.npm安装
  
  2.src/bus下创建index.ts：

    //引入mitt插件:mitt一个方法执行会返回bus对象
    import mitt from'mitt';
    const $bus = mitt(); 
    export default $bus;

  3.页面使用：引入暴露的bus对象，调用on绑定方法，emit触发方法。

    import $bus from "../../bus";
    import{ onMounted }from"vue";
    onMounted(() => {
      $bus.on("car",(car)=>{     //第一个参数:即为事件类型 第二个参数:即为事件回调
        console.log(car);
      });
    });

    //触发回调
    $bus.emit(car',{car:"法拉利"});



（vue3已经移除了sync了,跟v-model整合了）
### 1.4 vue3的v-model（注意）

  v-model指令可是收集表单数据(数据双向绑定)，除此之外它也可以实现父子组件数据同步。

    普通方法：prop结合自定义事件
    
    v-model同步用法1：(vue3中)（实践未成功，按用法2）

        <!-- v-model组件身上使用 -->
        第一:相当有给子组件传递props[modelValue]
        第二:相当于给子组件绑定自定义事件update:modelValue（其实是自定义名称）

        <Child v-model="money"></Child>
        （相当于给组件Child传递一个props(money)与绑定一个自定义事件update:money）

        子组件里面还需接收并调用let $emit=defineEmits(['update:searchStatus'])


   v-model同步用法2：(element-plug分页等常用,可以理解为就是一种简写)

        <Child v-model:pageNo="msg" v-model:pageSize="msg1"></Child>
      
        （特殊：在vue3中一个组件可以通过使用多个v-model,让父子组件多个数据同步,上方代码相当于给组件Child传递两个props分别是pageNo与pageSize，以及绑定两个自定义事件update:pageNo与update:pageSize实现父子数据同步）

          此时子组件Child内：
          let props = defineProps(["pageNo", "pageSize"]);
          let $emit = defineEmits(['update:pageNo', 'update:paagesize'])
          const handler=()=>{
            $emit("update:pageNo",props.pageNo+3);
          }


  


### 1.5 useAttrs 

  在Vue3中可以利用useAttrs方法获取组件的属性与事件(包含:原生DOM事件或者自定义事件),函数功能类似于Vue2框架中$attrs属性与$listeners方法。

  
  场景：封装一个鼠标移动到按钮上的组件。

  父页面：
  <template>
    <HintButton type="primary" size="small" :icon="Edit" @click="handler"></HintButtton>
  </template>


  HindButton组件:

  <template>
        <el-button :="$useAttrs"></el-button>
        <!-- 
        相当于：给标签绑定a属性和b属性，似乎挂载方法应该用v-on?
        特殊： :=vue3可以简写，vue2不可以
        <h1 v-bind="{a:1,b:2}">123</h1>
        <h1 :="{a:1,b:2}">123</h1>
         -->
  </template>
  <script setup lang="ts">
  //引入useAttrs方法:获取组件标签身上属性与事件，前提：属性只能获取到没有被prop接收的。事件若被接收，情况也一样。
  import { useAttrs } from 'vue';
  //此方法执行会返回一个对象
  let $useAttrs = useAttrs();
  </script>




### 1.6 ref与$parent （与vue2区别：数据得先暴露、获取组件后有需.value的情况）

  ref:可以获取真实的DOM节点,可以获取到子组件实例VC
  $parent:可以在子组件内部获取到父组件的实例
  vue3没了$children（注意）

父组件：
  <template>
    <div>
      <h1>ref与$parent</h1>
      <Son ref="son"></Son>
    </div>
  </template>
  <script setup lang="ts">
  import Son from "./Son.vue";
  import {ref } from "vue";
  const son = ref();  //变量名就是对应标签的ref名称
  const handler = ()=>{
    //操作子组件的数据，ref获取的为RefImpl对象
    son.value.money-=10; 
    son.value.fly();  //注意.value
}

  </script>


子组件： (vue3中组件内部的数据对外“关闭的”，外部不能访问，需要通过defineExpose对外暴露)
  <script setup lang="ts">
  import { ref } from "vue";
  //数据、方法
  let money = ref(1000);
  const handler = ()=>{
  }
  defineExpose({  //不需要引入,特殊；且后续获取不需要.value
    money,
    handler
  })
  </script>



子组件获取父组件实例VC：（父组件数据也得先对外暴露，同时子组件得使用方法）

  <template>
    <div>
      <button @click="handler($parent)">点击我爸爸给我10000元</button>
    </div>
  </template>

  <script setup lang="ts">
  import {ref} from 'vue';
  let money = ref(100);
  const handler = ($parent)=>{
     $parent.money=10000;   //注意不用.value，$parent获取的为Proxy对象
  }
  </script>





### 1.7provide与inject

**provide[提供]**

**inject[注入]**

  vue3提供两个方法provide与inject,可以实现隔辈组件传递参数

  组件组件提供数据:

  provide方法用于提供数据，此方法执需要传递两个参数,分别提供数据的key与提供数据value

  <script setup lang="ts">
  import {provide} from 'vue'
  let car=ref("法拉利");
  //两个参数:第一个参数就是提供的数据key,第二个参数:祖先组件提供数据
  provide("TOKEN", car)

  </script>


  后代组件可以通过inject方法获取数据,通过key获取存储的数值

  <script setup lang="ts">
  import {inject} from 'vue'
  let token = inject('token');
  const updateCar=()=>{
    token.value='自行车'  //可以同时修改父组件和子组件的该值
  }

  </script>



### 1.8pinia


  pinia也是集中式管理状态容器,类似于vuex。但是核心概念没有mutation、modules,使用方式参照官网


  大仓库写法一致：

    //创建大仓库
    import { createPinia } from 'pinia';
    //createPinia方法可以用于创建大仓库
    let store = createPinia();
    //对外暴露,安装仓库
    export default store;

    //最后再到入口文件引入


  小仓库两种写法：

      -选择式api写法(类似vuex):

        //定义info小仓库
        import { defineStore } from "pinia";

        //第一个参数:小仓库名字， 第二个参数:小仓库配置对象
        //defineStore方法执行会返回一个函数作用就是让组件可以获取到仓库数据
        let useInfoStore = defineStore("info", {
          state:()=>{
            return {
              count:99,
              arr: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
             }
          },
          actions: {
            //注意:函数没有context上下文对象，没有commit、没有mutations去修改数据
            updateNum(a: number, b: number) {
              this.count += a;
            }
           },
          getters:{
            total(){
              return  this.arr.reduce((prev: number, next: number)=>prev + next,0);
            }
           }
        })


      -组合式api写法:

        //定义组合式API仓库
        import { defineStore } from "pinia";
        import{ref,computed }from'vue';
        //创建小仓库方法，供暴露
        let useTodoStore = defineStore('todo', () => {  (其实类似setup)
            let todos = ref([{id:1,title:'吃饭' },{id:2,title:'睡觉'},{id:3,title:打豆豆'}]);
            let arr =  computed(()=>{
              return arr.value.reduce((prev, next)=>prev + next,0)
            })
            const updateTodo=()=>{  
                  todos.value.push({id:4,title:'组合式API方法'});
            }
            //务必要返回一个对象:属性与方法可以提供给组件使用
            return {
              todos,
              arr,
              updateTodo
            }
        })


  -pinia页面中调用数据：

    -直接仓库名.属性:   TabNavStore.globalDarkMode  
    （获取的仓库是proxy对象）

    -与v-model双向绑定，直接绑定
    （如果配合了页面的computed属性，需设置set）
    （体现优势：获取的仓库是proxy对象，可以直接双向绑定。
      在vuex中获取普通变量只是常量，没有地址内容影响
      ）

  -pinia的持久化存储：

  1.安装 
    npm i pinia-plugin-persistedstate

  2.pinia引用插件

    import piniaPersist from 'pinia-plugin-persist'
    const pinia = createPinia()
    pinia.use(piniaPersist)

    （引入时报错，npm install pinia-plugin-persist@latest）



  3.开启持久化存储
  
    a.整个小仓库数据全部存储，默认是sessionStorage
      persist:{  （state、actions同级处）
        enabled:true
      },

    b.存储小仓库部分属性
     persist:{
          enabled: true,
          strategies: [
            {
              key: 'bankList',   //key对应state中想要存储的变量名
              storage: sessionStorage
            }

            //或者
             { storage: localStorage, 
             paths: ['accessToken'] }
          ]
      }

    （开启持久化无效的问题：
    1.其他ts文件使用该仓库时，为了解决报错，使用了下面的形式：
      let userStore = useUserStore(pinia); 
      解决方法：let userStore = useUserStore();写在函数里面，也可以避开上面的报错。
    ）

      补充：ts文件使用let userStore = useUserStore()报错，是因为代码执行顺序的问题，如路由守卫，前置/后置回调外就会报错，因为仓库初始化还没完成。






### 1.9 slot （和vue2没区别）

  插槽：默认插槽、具名插槽、作用域插槽可以实现父子组件通信.（插槽只能通过子组件向父组件传递数据）


**默认插槽:**

  子组件

  <template>
    <div>
      <slot></slot>
    </div>
  </template>
  <script setup lang="ts">
  </script>
  <style scoped>
  </style>


  父组件

  <Todo>
    <h1>我是默认插槽填充的结构</h1>
  </Todo>


**具名插槽：**

  顾名思义，此插槽带有名字在组件内部留多个指定名字的插槽。

  子组件:

  <template>
    <div>
      <h1>todo</h1>
      <slot name="a"></slot>
      <slot name="b"></slot>
    </div>
  </template>
  <script setup lang="ts">
  </script>

  <style scoped>
  </style>


  父组件:  需要注意v-slot：可以替换为# （特殊）

  <template>
    <div>
      <h1>slot</h1>
      <Todo>
        <template v-slot:a>  （注意没有""）
          <div>填入组件A部分的结构</div>
        </template>
        <template v-slot:b>
          <div>填入组件B部分的结构</div>
        </template>
      </Todo>
    </div>
  </template>


  *默认插槽也能穿值

    父
    <template #default="scope"> //也可以在这里解构
                <slot name="search-custom" :scope="scope"></slot>
    </template>

    子：
    <slot :scope="{..}"></slot>




**作用域插槽**

作用域插槽：可以理解为，子组件数据由父组件提供，但是子组件内部决定不了自身结构与外观(样式)

子组件Todo代码如下:

<template>
  <div>
    <h1>todo</h1>
    <ul>
     <!--组件内部遍历数组-->
      <li v-for="(item,index) in todos" :key="item.id">
         <!--作用域插槽将数据回传给父组件-->
         <slot :$row="item" :$index="index"></slot>
      </li>
    </ul>
  </div>
</template>
<script setup lang="ts">
defineProps(['todos']);//接受父组件传递过来的数据
</script>
<style scoped>
</style>


父组件内部代码如下:

  <template>
    <div>
      <Todo :todos="todos">
        <!-- <template v-slot="{$row,$index}">  （建议接收方式使用slot-scope，因为当多个具体名插槽v-slot应该用来命名，实践未通过） -->
        <template v-slot:total="scope" >  //建议用这个方法接收,或者 #total="scope"
          <!--父组件决定子组件的结构与外观-->
          <span :style="{color:$row.done?'green':'red'}">{{$row.title}}</span>
        </template>
      </Todo>
    </div>
  </template>

  <script setup lang="ts">
  import Todo from "./Todo.vue";
  import { ref } from "vue";
  //父组件内部数据
  let todos = ref([
    { id: 1, title: "吃饭", done: true },
    { id: 2, title: "睡觉", done: false },
    { id: 3, title: "打豆豆", done: true },
  ]);
  </script>
  <style scoped>
  </style>






2.模版搭建

## 二、搭建后台管理系统模板

### 2.1项目初始化

今天来带大家从0开始搭建一个vue3版本的后台管理系统。一个项目要有统一的规范，需要使用eslint+stylelint+prettier来对我们的代码质量做检测和修复，需要使用husky来做commit拦截，需要使用commitlint来统一提交规范，需要使用preinstall来统一包管理工具。


#### 2.1.1环境准备

  - node v16.14.2 （vite要求16+）
  - pnpm 8.0.0  (使用npm即可)

#### 2.1.2初始化项目

  本项目使用vite进行构建  

  **pnpm:performant npm ，意味“高性能的 npm”。[pnpm](https://so.csdn.net/so/search?q=pnpm&spm=1001.2101.3001.7020)由npm/yarn衍生而来，解决了npm/yarn内部潜在的bug，极大的优化了性能，扩展了使用场景。被誉为“最先进的包管理工具”**

   npm install pnpm -g

  - 安装vite

    npm install -g vite

  - 项目初始化命令:

    npm create vite
    可视化输入项目名称、选择框架、js语法
    npm install安装依赖
    运行程序:pnpm run dev


  - 项目结构与vue2不同：

    index.html静态页面在根目录下, 其它均相似。


  Vite 与 Vue-cli 创建项目的一些不同 ：
    1.Vue-cli可以选择eslint，babal..，Vite不能。
    2.vite修改配置文件不需要重启，脚手架需要重启服务
  

### 2.2项目配置

  --open 在package.json命令中，此命令可以使项目运行后自动打开网页

  --配置快捷键,输入提示生成vue3+ts模板，vue3ts
  （VS找到配置用户代码片段，新建一个，内容格式如下）

  "Print to console": {
		"prefix": "vue3",//此处关系到你的快捷单词
		"body": [
		  "<template>",
		  "  ",
		  "</template>",
		  "",
		  "<script setup lang='ts'>",
		  "  ",
		  "</script>",
		  "",
		  "<style scoped lang='scss'>",
		  "  ",
		  "</style>"
	  ],
	  }

  - vue3+ts基础模版不同：
    1.script标签默认就是setup()内部:
    2.直接写变量/方法，默认return，挂载到该vue组件上。
    <!-- <script setup lang="ts"> （也可以不用这种简写） -->



3.安装校验规范工具


#### 一、eslint配置（也能检测TS）

**eslint中文官网:http://eslint.cn/**

ESLint最初是由[Nicholas C. Zakas](http://nczonline.net/) 于2013年6月创建的开源项目。它的目标是提供一个插件化的**javascript代码检测工具**

-首先安装eslint：
  npm i eslint -D

-生成配置文件:.eslint.cjs
  npx eslint --init 
  一系列可视化选择（可参考图）



**.eslint.cjs配置文件**


module.exports = {
   //运行环境（eslint工作的环境）
    "env": { 
        "browser": true,//浏览器端
        "es2021": true,//es2021
    },

    //规则继承
    "extends": [ 
       //全部规则默认是关闭的,这个配置项开启推荐规则,推荐规则参照文档
       //比如:函数不能重名、对象不能出现重复key
        "eslint:recommended",
        //vue3语法规则
        "plugin:vue/vue3-essential",
        //ts语法规则
        "plugin:@typescript-eslint/recommended"
    ],

    //要为特定类型的文件指定处理器
    "overrides": [
    ],

    //指定解析器:解析器
    //Esprima 默认解析器
    //Babel-ESLint babel解析器
    //@typescript-eslint/parser ts解析器
    "parser": "@typescript-eslint/parser",
    //指定解析器选项
    "parserOptions": {
        "ecmaVersion": "latest",//校验ECMA最新版本
        "sourceType": "module"//设置为"script"（默认），或者"module"代码在ECMAScript模块中
    },

    //ESLint支持使用第三方插件。在使用插件之前，您必须使用npm安装它
    //该eslint-plugin-前缀可以从插件名称被省略
    "plugins": [
        "vue",
        "@typescript-eslint"
    ],
    //eslint规则
    "rules": {
    }
}


##### 1.1vue3环境代码校验插件


# 让所有与prettier规则存在冲突的Eslint rules失效，并使用prettier进行代码检查
"eslint-config-prettier": "^8.6.0",
"eslint-plugin-import": "^2.27.5",
"eslint-plugin-node": "^11.1.0",
# 运行更漂亮的Eslint，使prettier规则优先级更高，Eslint优先级低
"eslint-plugin-prettier": "^4.2.1",
# vue.js的Eslint插件（查找vue语法错误，发现错误指令，查找违规风格指南
"eslint-plugin-vue": "^9.9.0",
# 该解析器允许使用Eslint校验所有babel code
"@babel/eslint-parser": "^7.19.1",


安装指令


pnpm install -D eslint-plugin-import eslint-plugin-vue eslint-plugin-node eslint-plugin-prettier eslint-config-prettier eslint-plugin-node @babel/eslint-parser


##### 1.2修改.eslintrc.cjs配置文件


// @see https://eslint.bootcss.com/docs/rules/

module.exports = {
  env: {
    browser: true,
    es2021: true,
    node: true,
    jest: true,
  },
  /* 指定如何解析语法 */
  parser: 'vue-eslint-parser',
  /** 优先级低于 parse 的语法解析配置 */
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
    parser: '@typescript-eslint/parser',
    jsxPragma: 'React',
    ecmaFeatures: {
      jsx: true,
    },
  },
  /* 继承已有的规则 */
  extends: [
    'eslint:recommended',
    'plugin:vue/vue3-essential',
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  plugins: ['vue', '@typescript-eslint'],
  /*
   * "off" 或 0    ==>  关闭规则
   * "warn" 或 1   ==>  打开的规则作为警告（不影响代码执行）
   * "error" 或 2  ==>  规则作为一个错误（代码不能执行，界面报错）
   */
  rules: {    //官网有相应的规则配置项
    // eslint（https://eslint.bootcss.com/docs/rules/）
    'no-var': 'error', // 要求使用 let 或 const 而不是 var
    'no-multiple-empty-lines': ['warn', { max: 1 }], // 不允许多个空行
    'no-console': process.env.NODE_ENV === 'production' ? 'error' : 'off',
    'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off',
    'no-unexpected-multiline': 'error', // 禁止空余的多行
    'no-useless-escape': 'off', // 禁止不必要的转义字符

    // typeScript (https://typescript-eslint.io/rules)
    '@typescript-eslint/no-unused-vars': 'error', // 禁止定义未使用的变量
    '@typescript-eslint/prefer-ts-expect-error': 'error', // 禁止使用 @ts-ignore
    '@typescript-eslint/no-explicit-any': 'off', // 禁止使用 any 类型
    '@typescript-eslint/no-non-null-assertion': 'off',
    '@typescript-eslint/no-namespace': 'off', // 禁止使用自定义 TypeScript 模块和命名空间。
    '@typescript-eslint/semi': 'off',

    // eslint-plugin-vue (https://eslint.vuejs.org/rules/)
    'vue/multi-word-component-names': 'off', // 要求组件名称始终为 “-” 链接的单词
    'vue/script-setup-uses-vars': 'error', // 防止<script setup>使用的变量<template>被标记为未使用
    'vue/no-mutating-props': 'off', // 不允许组件 prop的改变
    'vue/attribute-hyphenation': 'off', // 对模板中的自定义组件强制执行属性命名样式
  },
}



##### 1.3.eslintignore忽略文件


创建.eslintignore文件，内容：
dist
node_modules


##### 1.4.eslint运行脚本

package.json新增两个运行脚本


"scripts": {
    "lint": "eslint src",
    "fix": "eslint src --fix",
}



#### 二、配置**prettier**

有了eslint，为什么还要有prettier？eslint针对的是javascript，他是一个检测工具，包含js语法以及少部分格式问题，在eslint看来，语法对了就能保证代码正常运行，格式问题属于其次；

而prettier属于格式化工具，它看不惯格式不统一，所以它就把eslint没干好的事接着干，另外，prettier支持包含js在内的多种语言。

总结起来，**eslint和prettier这俩兄弟一个保证js代码质量，一个保证代码美观。**

##### 2.1安装依赖包


pnpm install -D eslint-plugin-prettier prettier eslint-config-prettier


##### 2.2.创建prettierrc.json添加规则


{
  "singleQuote": false,  //要求字符串都是单引号
  "semi": false,    //不要;
  "bracketSpacing": true,
  "htmlWhitespaceSensitivity": "ignore",
  "endOfLine": "auto",
  "trailingComma": "all",
  "tabWidth": 2
}


##### 2.3 .prettierignore忽略文件


/dist/*
/html/*
.local
/node_modules/**
**/*.svg
**/*.sh
/public/*


**通过pnpm run lint去检测语法，如果出现不规范格式,通过pnpm run fix 修改**



#### 三、配置stylelint

[stylelint](https://stylelint.io/)为css的lint工具。可格式化css代码，检查css语法错误与不合理的写法，指定css书写顺序等。

我们的项目中使用scss作为预处理器，安装以下依赖：


pnpm add sass sass-loader stylelint postcss postcss-scss postcss-html stylelint-config-prettier stylelint-config-recess-order stylelint-config-recommended-scss stylelint-config-standard stylelint-config-standard-vue stylelint-scss stylelint-order stylelint-config-standard-scss -D



##### 3.1 .stylelintrc.cjs**配置文件**

**官网:https://stylelint.bootcss.com/**


// @see https://stylelint.bootcss.com/

module.exports = {
  extends: [
    'stylelint-config-standard', // 配置stylelint拓展插件
    'stylelint-config-html/vue', // 配置 vue 中 template 样式格式化
    'stylelint-config-standard-scss', // 配置stylelint scss插件
    'stylelint-config-recommended-vue/scss', // 配置 vue 中 scss 样式格式化
    'stylelint-config-recess-order', // 配置stylelint css属性书写顺序插件,
    'stylelint-config-prettier', // 配置stylelint和prettier兼容
  ],
  overrides: [
    {
      files: ['**/*.(scss|css|vue|html)'],
      customSyntax: 'postcss-scss',
    },
    {
      files: ['**/*.(html|vue)'],
      customSyntax: 'postcss-html',
    },
  ],
  ignoreFiles: [
    '**/*.js',
    '**/*.jsx',
    '**/*.tsx',
    '**/*.ts',
    '**/*.json',
    '**/*.md',
    '**/*.yaml',
  ],
  /**
   * null  => 关闭该规则
   * always => 必须
   */
  rules: {
    'value-keyword-case': null, // 在 css 中使用 v-bind，不报错
    'no-descending-specificity': null, // 禁止在具有较高优先级的选择器后出现被其覆盖的较低优先级的选择器
    'function-url-quotes': 'always', // 要求或禁止 URL 的引号 "always(必须加上引号)"|"never(没有引号)"
    'no-empty-source': null, // 关闭禁止空源码
    'selector-class-pattern': null, // 关闭强制选择器类名的格式
    'property-no-unknown': null, // 禁止未知的属性(true 为不允许)
    'block-opening-brace-space-before': 'always', //大括号之前必须有一个空格或不能有空白符
    'value-no-vendor-prefix': null, // 关闭 属性值前缀 --webkit-box
    'property-no-vendor-prefix': null, // 关闭 属性前缀 -webkit-mask
    'selector-pseudo-class-no-unknown': [
      // 不允许未知的选择器
      true,
      {
        ignorePseudoClasses: ['global', 'v-deep', 'deep'], // 忽略属性，修改element默认样式的时候能使用到
      },
    ],
  },
}


##### 3.2 .stylelintignore忽略文件


/node_modules/*
/dist/*
/html/*
/public/*


##### 3.3运行脚本


"scripts": {
	"lint:style": "stylelint src/**/*.{css,scss,vue} --cache --fix"
}


最后配置统一的prettier来格式化我们的js和css，html代码


 "scripts": {
    "dev": "vite --open",
    "build": "vue-tsc && vite build",
    "preview": "vite preview",
    "lint": "eslint src",
    "fix": "eslint src --fix",
    "format": "prettier --write \"./**/*.{html,vue,ts,js,json,md}\"",
    "lint:eslint": "eslint src/**/*.{ts,vue} --cache --fix",
    "lint:style": "stylelint src/**/*.{css,scss,vue} --cache --fix"
  },


**当我们运行pnpm run format的时候，会把代码直接格式化**


---只完成上面的配置---


#### 四、配置husky

在上面我们已经集成好了我们代码校验工具，但是需要每次手动的去执行命令才会格式化我们的代码。如果有人没有格式化就提交了远程仓库中，那这个规范就没什么用。所以我们需要强制让开发人员按照代码规范来提交。

要做到这件事情，就需要利用husky在代码提交之前触发git hook(git在客户端的钩子)，然后执行pnpm run format来自动的格式化我们的代码。

安装husky


pnpm install -D husky


执行


npx husky-init


会在根目录下生成个一个.husky目录，在这个目录下面会有一个pre-commit文件，这个文件里面的命令在我们执行commit的时候就会执行

在.husky/pre-commit文件添加如下命令：


#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"
//npm test
pnpm run format


当我们对代码进行commit操作的时候，就会执行命令，对代码进行格式化，然后再提交。



#### 五、配置commitlint

对于我们的commit信息，也是有统一规范的，不能随便写,要让每个人都按照统一的标准来执行，我们可以利用**commitlint**来实现。

安装包


pnpm add @commitlint/config-conventional @commitlint/cli -D


添加配置文件，新建commitlint.config.cjs(注意是cjs)，然后添加下面的代码：


module.exports = {
  extends: ['@commitlint/config-conventional'],
  // 校验规则
  rules: {
    'type-enum': [
      2,
      'always',
      [
        'feat',
        'fix',
        'docs',
        'style',
        'refactor',
        'perf',
        'test',
        'chore',
        'revert',
        'build',
      ],
    ],
    'type-case': [0],
    'type-empty': [0],
    'scope-empty': [0],
    'scope-case': [0],
    'subject-full-stop': [0, 'never'],
    'subject-case': [0, 'never'],
    'header-max-length': [0, 'always', 72],
  },
}


在package.json中配置scripts命令


# 在scrips中添加下面的代码
{
"scripts": {
    "commitlint": "commitlint --config commitlint.config.cjs -e -V"
  },
}


配置结束，现在当我们填写commit信息的时候，前面就需要带着下面的subject


'feat',//新特性、新功能
'fix',//修改bug
'docs',//文档修改
'style',//代码格式修改, 注意不是 css 修改
'refactor',//代码重构
'perf',//优化相关，比如提升性能、体验
'test',//测试用例修改
'chore',//其他修改, 比如改变构建流程、或者增加依赖库、工具等
'revert',//回滚到上一个版本
'build',//编译相关的修改，例如发布版本、对项目构建或者依赖的改动


配置husky


npx husky add .husky/commit-msg 


在生成的commit-msg文件中添加下面的命令

#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"
pnpm commitlint


当我们 commit 提交信息时，就不能再随意写了，必须是 git commit -m 'fix: xxx' 符合类型的才可以，**需要注意的是类型的后面需要用英文的 :，并且冒号后面是需要空一格的，这个是不能省略的**




#### 六、强制使用pnpm包管理器工具

团队开发项目的时候，需要统一包管理器工具,因为不同包管理器工具下载同一个依赖,可能版本不一样,

导致项目出现bug问题,因此包管理器工具需要统一管理！！！

在根目录创建scritps/preinstall.js文件，添加下面的内容


if (!/pnpm/.test(process.env.npm_execpath || '')) {
  console.warn(
    \u001b[33mThis repository must using pnpm as the package manager  +
     for scripts to work properly.\u001b[39m\n,
  )
  process.exit(1)
}


配置命令

"scripts": {
	"preinstall": "node ./scripts/preinstall.js"
}


**当我们使用npm或者yarn来安装包的时候，就会报错了。原理就是在install的时候会触发preinstall（npm提供的生命周期钩子）这个文件里面的代码。**




## 三、项目集成

### 3.1集成element-plus：

  - 安装 npm install element-plus --save

  - 入口文件main.ts引入： （element-plus默认支持语言英语设置为中文）

    import ElementPlus from 'element-plus';
    import 'element-plus/dist/index.css'
    import zhCn from 'element-plus/dist/locale/zh-cn.mjs'
    app.use(ElementPlus, {
        locale: zhCn
    })



**Element Plus全局组件类型声明**（不懂）

  // tsconfig.json
  {
    "compilerOptions": {
      // ...
      "types": ["element-plus/global"]
    }
  }


### 3.2src别名的配置

在开发项目的时候文件与文件关系可能很复杂，因此我们需要给src文件夹配置一个别名

// vite.config.ts
import {defineConfig} from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'
export default defineConfig({
    plugins: [vue()],
    resolve: {
        alias: {
            "@": path.resolve("./src") // 相对路径别名配置，使用 @ 代替 src
        }
    }
})


**TypeScript 编译配置**（不懂）


// tsconfig.json
{
  "compilerOptions": {
    "baseUrl": "./", // 解析非相对模块的基地址，默认是当前目录
    "paths": { //路径映射，相对于baseUrl
      "@/*": ["src/*"] 
    }
  }
}


### 3.3环境变量的配置

开发环境（development）
顾名思义，开发使用的环境，每位开发人员在自己的dev分支上干活，开发到一定程度，同事会合并代码，进行联调。

测试环境（testing）
测试同事干活的环境啦，一般会由测试同事自己来部署，然后在此环境进行测试

生产环境（production）
生产环境是指正式提供对外服务的，一般会关掉错误报告，打开错误日志。(正式提供给客户使用的环境。)

.env.development
.env.production
.env.test

文件内容

# 变量必须以 VITE_ 为前缀才能暴露给外部读取 （VITE项目独有）
NODE_ENV = 'development'
VITE_APP_TITLE = '硅谷甄选运营平台'
VITE_APP_BASE_API = '/dev-api'

配置运行命令：package.json

 "scripts": {
    "dev": "vite --open",
    "build:test": "vue-tsc && vite build --mode test",
    "build:pro": "vue-tsc && vite build --mode production",
    "preview": "vite preview"
  },

通过import.meta.env获取环境变量



### 3.4 SVG图标配置 

特点：
1.内存小加载快
2.放大不会失帧（字体图标会）
3.用宽高控制大小、fill属性控制颜色(字体图标使用字体大小 字体颜色控制)。



**1.安装SVG依赖插件**

  pnpm install vite-plugin-svg-icons -D

**2.在vite.config.ts中配置插件**

  import { createSvgIconsPlugin } from 'vite-plugin-svg-icons'
  import path from 'path'
  export default () => {
    return {
      plugins: [
        createSvgIconsPlugin({
          // Specify the icon folder to be cached
          iconDirs: [path.resolve(process.cwd(), 'src/assets/icons')],
          // Specify symbolId format
          symbolId: 'icon-[dir]-[name]',
        }),
      ],
    }
  }


**3.入口文件导入**

  import 'virtual:svg-icons-register'  （必须）

  4.直接在src/assets/icons文件夹资源中分别创建svg文件，复制官网的单独图标svg代码（或者直接下载svg文件放入）

  5.使用

    -单个svg用法

        <!-- 
        <svg style="width:30px;height:30px">
            <use xlink:href="#icon-phone" fill='color'></use>
        </svg> 
        -->

        注意：
        1.svg:图标外层容器节点,内部需要与use标签结合使用
        2.xlink:href执行用哪一个图标，前缀一般是#icon-
        3.使用use标签的fill属性修改颜色无效：在.svg文件代码中去掉fill行内属性即可。
        4.fill内外都没有设置默认是黑色


    -封装成组件：（由于很多地方要用到，所以封装成全局组件。并只注册一次）

        <template>
          <div>
            <svg :style="{ width: width, height: height }">
              <use :xlink:href="prefix + name" :fill="color"></use>
            </svg>
          </div>
        </template>
 
        <script setup lang="ts">
        defineProps({
          //xlink:href属性值的前缀
          prefix: {
            type: String,
            default: '#icon-'
          },
          ...

        })
        </script>


    -注册全局组件

        import SvgIcon from './SvgIcon/index.vue';
        import Pagination from './Pagination/index.vue
        //全局对象
        const allGloablComponent = { SvgIcon, Pagination };   （注意写法）
        //对外暴露插件对象
        export default {
          install(app){
            //注册项目全部的全局组件
            Object.keys(allGloablComponent).forEach(key => {
            //注册为全局组件
            app.component(key, allGloablComponent[key]);
          })
          }
        }


  -使用自定义插件：
  
      import gloablComponent from './components/index';
      app.use(gloablComponent);



### 3.5集成sass

  - scss只要安装便可直接使用

  <style scoped lang="scss"></style>


  - 为项目添加一些全局的样式

    在src/styles目录下创建一个index.scss文件，当然项目中需要用到清除默认样式，因此在index.scss引入reset.scss
    
    在入口文件引入,import '@/styles'

  - 发现在src/styles/index.scss全局样式文件中没有办法使用$变量.因此需要给项目中引入全局变量$.

    在vite.config.ts文件配置如下:

      export default defineConfig((config) => {
        css: {
            preprocessorOptions: {
              scss: {
                javascriptEnabled: true,
                additionalData: '@import "./src/styles/variable.scss";',  //后面的;不要忘记，不然会报错
              },
            },
          },
      }



### 3.6 mock数据

pnpm install -D vite-plugin-mock mockjs

在 vite.config.js 配置文件启用插件。

import { UserConfigExport, ConfigEnv } from 'vite'
import { viteMockServe } from 'vite-plugin-mock'
import vue from '@vitejs/plugin-vue'
export default ({ command })=> {
  return {
    plugins: [
      vue(),
      viteMockServe({
        localEnabled: command === 'serve',
      }),
    ],
  }
}

在根目录创建mock文件夹，在文件夹内部创建一个user.ts文件




**安装axios**

  npm install axios

### 3.7 axios二次封装

  目的:

  1:使用请求拦截器，可以在请求拦截器中处理一些业务(开始进度条、请求头携带公共参数)

  2:使用响应拦截器，可以在响应拦截器中处理一些业务(进度条结束、简化服务器返回的数据、处理http网络错误)

  在根目录下创建utils/request.ts

  import axios from "axios";
  import { ElMessage } from "element-plus";
  //创建axios实例
  let request = axios.create({
      baseURL: import.meta.env.VITE_APP_BASE_API,
      timeout: 5000
  })
  //请求拦截器
  request.interceptors.request.use(config => {
      return config;
  });
  //响应拦截器
  request.interceptors.response.use((response) => {
      return response.data;
  }, (error) => {
      //处理网络错误
      let msg = '';
      let status = error.response.status;
      switch (status) {
          case 401:
              msg = "token过期";
              break;
         ...
      }
      ElMessage({
          type: 'error',
          message: msg
      })
      return Promise.reject(error);
  });
  export default request;


### 3.8API接口统一管理

  在开发项目的时候,接口可能很多需要统一管理。在src目录下去创建api文件夹去统一管理项目的接口；

  import request from '@/utils/request'

  import type {
    loginFormData,
    ...
  } from './type'

  enum API {
  LOGIN_URL = '/admin/acl/index/login',
  ...
  }
  //登录接口
  export const reqLogin = (data: loginFormData) =>
  request.post<any, loginResponseData>(API.LOGIN_URL, data)
  export const reqLogout = () => request.post<any, any>(API.LOGOUT_URL)



## 四、项目的资源地址

服务器域名:http://sph-api.atguigu.cn
swagger文档:
http://139.198.104.58:8209/swagger-ui.html
http://139.198.104.58:8212/swagger-ui.html#/




## 大屏


  <style>
        * {
            margin: 0;
            padding: 0;
        }

        /* 外容器只是作为铺不满全屏时的背景 */
        .container {
            width: 100vw;
            height: 100vh;
            background: url(./bg.png) no-repeat;
            background-size: cover;
        }

        .box {
            position: fixed;
            width: 1920px;
            height: 1080px;
            background: red;
            /* transform-origin: left top; */
            left: 50%;
            top: 50%;
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- 数据展示的区域 -->
        <div class="box">
        </div>
    </div>
</body>

</html>
<script>
    let box = document.querySelector('.box');
    box.style.transform = `translate(-50%,-50%) scale(${getScale()}) `
    //计算缩放的比例啦
    function getScale(w = 1920, h = 1080) {
        const ww = window.innerWidth / w;
        const wh = window.innerHeight / h;
        return ww < wh ? ww : wh;
        //ww<wh情况: 1920/1920(ww)   1080/1080(wh)
        //ww>wh情况:1920/1920(ww)   1080/1080(wh)
    }
    window.onresize = () => {
        box.style.transform = `translate(-50%,-50%) scale(${getScale()}) `
    }

</script>




-------------------------------------------------------------------------------------------------------------


 # 自主开发笔记：

  1.vite搭建项目，可视化选择框架，语法。
  2.安装校验规范工具。js方面:eslint、prettier。css方面：stylelintrc  
  3.提交前规范。husky、commitlint。（跳）
  4.安装 引入element-plus、安装scss，设置全局scss样式及变量
    注意：1.安装element-plus时引入分页等是英文的，需配置一个国际化，设置为中文
          2.scss直接安装后即可使用
          3.全局scss样式：新建reset.css清楚默认样式（npm官网搜索，然后复制）
             globalStyle.scss文件引入resetcss：注意格式是@import './reset.scss'; (;不要省略)
             globalVariable.scss文件集中管理全局变量$，此时页面使用$xx变量在需其它文件寻找，vite找不到会报错，配置全局变量路径给vite。
             （如果是$单个文件内使用，没有这问题）
             less用@,不用$
          4.可以在全局样式设置平时符合习惯的属性，如：box-sizing: border-box;

    拓展：插件vue-helper,会提示element-ui标签


  5.TypeScript 编译配置（跳）、环境变量的配置、SVG图标配置。
    注意：
      1.vue3中环境变量的写法不同：（注意）
        -在Vue3中将环境变量暴露给外部进行读取，必须以VITE_为前缀命名变量，否则其它地方获取不到该变量（特殊）
        -vue2使用 process.env获取环境变量
        -在vue3中不生效，需使用 import.meta.env 获取环境变量
        -vite.config.ts中无法使用import.meta.env，需let env = loadEnv(mode, process.cwd());

      2.生产环境下，vite与vue-cli不同，在打包成静态资源后，前者还能使用插件进行代理，后者不能提供代理。

      
  6.src别名的配置、全局组件封装
    注意：1.若配置@路径后没有代码提示，解决方法：
            -vs-code下载“Path Intellisense”插件，
            -打开设置-首选项-搜索Path Intellisense-打开settings.json ，添加
                "path-intellisense.mappings": {
                      "@": "${workspaceRoot}/src"
                }

           2.注册全局组件，可以统一写在自定义插件中：




  7.mock数据
  npm install -D vite-plugin-mock mockjs  
  vite-plugin-mock的用法在npm官网查找也能找到。vite.config.js 配置文件启用插件, 之后在mock文件夹下写文件即可，对外暴露数组，数组元素为接口。
    export default ({ command })=> {  //command与环境有关
      return {
        plugins: [
          vue(),
          viteMockServe({
            localEnabled: command === 'serve',
          }),
        ],
      }
    }
  注意：(特殊)
    1.不用指定mock数据的路径或者引入
    2.即使请求有全局基础路径也不会代理。


  8.axios安装与二次封装
    注意：
        1.不需要vue.use(axios)

  9.API接口统一管理
    注意： 1.import type {} 不会导入实际的代码，只会导入类型信息
      

  10.router配置
      注意：1.vue2需要Vue.use(Router构造函数)，且vue2在new Vue中需要传router实例。
              vue3只需要vue实例.use(router实例)。
           2.scrollBehavior可定义滚动行为：路由切换时滚动条置顶，水平东西到最左
           3.需<router-view></router-view>展示路由
           4.路由导入注意细节：（vue3 和 vue2的导入有区别）
              路由导入：component: () => import('/src/views/login.vue')
              组件导入：import Top from '/src/views/home/top.vue'
              即：vue3的导入不能省略文件后缀，否则报红且直接报错


      拓展：
         *vue3+ts项目的报红警告问题：
          1.引入文件有时候需完整引入文件名和后缀，否则爆红+报错
          2.引入vue文件爆红：（因为ts文件不识别vue文件）

              -src下/根目录自定义：xxx.d.ts
              declare module '*.vue' {  //解决ts文件引入vue文件出现红色警告问题
                  import type { DefineComponent } from 'vue'   // 引入vue模块中ts的方法
                  const component: DefineComponent<{}, {}, any>  // 定义vue组件以及类型注解
                  export default component
                }

              -（也可能是因为VS的语法提示插件vetur对vue3不太兼容：
              解决方法：卸载插件vetur，重启。Volar插件对vue3支持较好
              ）

          3.页面/ts文件中引入其它ts文件有时候爆红：
              -//@ts-ignore 跳过下一行的ts检测，一般用在入口文件。否则爆红+打包报错，但是能运行。（因为.ts文件在引入文件时，没有声明ts类型）
              -.ts可以省略，直接写文件名就好：
              （An import path can only end with a '.ts' extension when 'allowImportingTsExtensions' is enabled）


        *打包时的报错： （不懂）
          1.引入的ts文件没有声明类型
          2.promise两个回调返回值没有声明类型
        
        *tsconfig.json对编译ts的影响（不懂）
          作用： 1.将 TypeScript 编译成哪个版本的 JavaScript。
                 2.在编译过程中也会进行类型检测，如果发现类型错误，将会编译失败。



    11.登录功能：静态页面布局、点击让仓库发请求、判断结果返回到组件，组件内提示并动态提示时间信息
      注意：
        1.页面高度100%问题: html,body,#app可以一起设置100%，高度后续继承才方便
        2.关于接口请求失败的提示问题：在全局的请求拦截器中，
            -若请求后台没返回结果，根据错误对象的响应状态码处理为404、网络出错等问题
            -有请求返回结果，但是非200状态码，则根据通常状态码判断情况回显给用户
            -请求结果状态码为200，在成功回调中直接拿值
          按上面的设计方法，页面中请求方法调用后只then不用catch也可以；await直接获取结果也可以（该方式方便，但是没try catch会不严谨，有的话繁琐，失去await意义，辩证分析）；一旦接口请求失败，都会控制台报错而已。

        3.vue3中ref获取组件:
          let formRef = ref();
          获取组件实例formRef.value

        4.安装、使用pinia (如果vite是4.3.2，不是最新版，pinia也不能安装最新版)
          步骤：
              1.npm install pinia
              2.store文件夹下index.ts创建大仓库,对外暴露
              3.main.ts入口文件引入大仓库
              4.store文件夹下modules文件夹里创建小仓库，对外暴露（是一个函数，需用该仓库时，引入再调用即可）
              5.页面使用时调用小仓库暴露的函数，获得的对象里拥有小仓库的方法和属性

         5.token封装成全局持久化方法，便于管理

         6.vue3在页面中引入路由信息和路由对象：
            import { useRouter,useRoute } from "vue-router";
            let $router=useRouter();
            let $route=useRoute();

         7.登录成功后：
          回调中持久化存储token，并同步state中的token值（两步需同时有）。
          判断当前路由是否有requery参数，有则跳转，无则跳转首页。

          账号密码：
          "username":"admin"
          "password":"atguigu123"

         8.接口类型限制没效果(跳)

         9.注意一些状态码：
          -404：url拼写错误、get/post请求方法错误。
          -400：
            请求参数缺失或格式错误、错误的请求方法、请求的资源在服务器上不存在、权限不足、请求体内容错误。


    12.一级路由layout：layout组件布局编写，抽离部分全局样式变量
      注意：
          1.侧边栏和顶部写死宽度/高度，全局抽离出变量，注意同级div高度calc(100% - xx)。
          2.logo+标题封装成组件，setting.ts暴露对象供设置标题和logo
          3.vue3引入组件后,不用注册，因为setup简写的写法


     13.动态路由：
       注意：
          1.系统框架下的二级路由尽量不要带一级路由的路径，避免耦合，菜单根据path跳转问题需添加一级基础路径。layout布局组件在多个菜单的一级路由被引用。
          2.将路由数组添加到用户store中，作为用户的菜单属性；再去页面引入用户store
          3.动态渲染路由时，注意：
            - 区分情况，是否有子路由，只有一个子路由也展开，递归是排除path'/'即可
             （先考虑两层的情况，考虑三层及以上需要递归）
            - 不是所有路由都需要展示，得隐藏部分/过滤数组
             （一般可以考虑hidden在第一层，考虑多层则先过滤方便）
            - <component :is=xx />动态渲染图标，element-plus图标是组件形式
             （ 需将icon所有图标注册为全局组件，Object.entries：将对象变成键值的数组,每对属性和属性值对应生产一个数组元素;再解构赋值）
            - 三级以上路由，递归使用组件时，需给组件命名，然后传值需基础路径(需叠加)
          4.el-menu的default-active需动态地址栏路径关联，且每个菜单index应该拼接为完整路径，确保每个最小的子项，index属性都是完整路径。


      14.顶部区域：
      
      - 折叠菜单：创建小仓库存储展开状态，顶部组件引入展开状态值，动态变化图标，同时layout组件的左侧根据是否折叠添加自定义样式名，在折叠下的样式修改左侧菜单宽度即可。

        注意：
            1.el-scrollbar设置高度，溢出时滚动条样式自动处理（其实和设置滚动条差不多）
            2.关于el-menu菜单，collapse折叠效果异常的问题：
              -必需有<template #title>显示标题，无论有没有展开项，勿省略。
              -若有子项的菜单，<template #title>里必需<span></span>包裹标题。
            3.尺寸变化，若小尺寸屏幕，已经展开变为折叠。大尺寸屏幕则相反，给window添加reize监测事件即可，一般写在layout的index.vue。

      - 面包屑：$route.matched可以获取匹配到的路由分支的对象数组，只需在面包屑循环该数组即可，且每一层里面的path会自动拼接。

      -全屏：
      document.fullscreenElement判断是否全屏
      document.documentElement.requestFullscreen()进入全屏
      document.exitFullscreen()退出全屏

      -刷新功能：点击刷新二级路由
      主区域再写一个二级路由的<router-view>即可，将刷新状态放在小仓库，只有该刷新属性变化，二级路由就重新渲染（其实就是组件跨级通讯）

      -底部公司标识
      


      15.路由鉴权：
        
        -获取用户信息：在前置守卫判断有token之后，没有用户信息则获取。比起在首页挂载/登录成功回调里获取更佳。（此处没有使用持久化存储）
        -路由跳转进度条：
            npm i nprogress  //安装
            import nprogress from 'nprogress'  //引入
            import 'nprogress/nprogress.css'
            NProgress.start();   //调用
            NProgress.done();
            注意：它是js插件，没有ts类型，会爆红，可忽略检测，可以在引入的Css文件中修改样式。

        
        -前置路由思路：

          先判断是否有token：
            1.有。不能再跳转登录页，其它均可以。再顺便是否有用户信息，没有则请求。
            2.没有。若是跳转的路径是在白名单中或者'/login'，则直接通过。
                    若是其它路径，则router的query参数存放要去的路径，重定向'/login'
     

          -重定向回'/login'时，需记住想去的路由地址/当前路由地址的情况：
            1.请求拦截器中，请求接口发现token过期/没携带，不能请求时，记住当前路由地址。
            2.跳转路由时发现没有token不能跳转时，记住想去的路由地址。

          -请求拦截器中，请求接口时token过期或者不存在：（后端返回401/403等等）
            清空token、用户信息，location.reload原地加载页面。

          -退出登录：
            清空token、用户信息，将登出成功告知页面，让页面去跳转。


      *注意：
          2.vue2/vue3一样，ts/js文件没法找到route/router对象，可以使用原生location.reload()原地加载。（location.reload可以间接实现记住当前路径）
          3.利用router的query参数可以存储要跳转的路径。
          4.vue-router的query和params参数的主要区别与相同点：
            -都可以this.$route.xx获取，this.$router.push跳转时都可以通过拼接path跳转、对象参数来跳转。
            -params是在path中占位，一般必须占位。
            -显示上，query以键值对显示，params则通过占位隐藏参数名。


      15.导航区域：
        
        -el-tabs会自带溢出处理，左右出现小箭头。
        -通过路由变化后的路由信息存入小仓库，el-tabs循环小仓库数组。
        -选中项为完整路由路径，再考虑删除tab后，选中项的改变。
        -样式的问题：

          1.右键切片只出现一个弹出框，el-dropdown默认只有鼠标移动/点击到上面才有互斥效果。可以考虑自定义组件。

          解决方法：
          v-on:contextmenu.prevent
          vue自带的鼠标右键方法，prevent阻止默认弹框。

          2.点击其它位置关闭弹框、弹出菜单被溢出处理问题
            document.body.addEventListener，给页面根元素添加点击事件，同时开启捕获模式，此时父元素一定会触发点击事件


          3.如何只显示一个菜单（场景在原生高频出现）  
        
          4.右键菜单的功能、选中时的背景框修改。
          5.弹出菜单的位置确定：利用事件触发节点在父容器的定位。


      16.约束接口：（注意）
        promise中的规范<any,数据返回的规范>。
        参数或者返回属性都是限定内容。
        限定：定义接口、调用接口的传入与返回、页面中与传入接口有关的变量类型：ref<any>(x)）
        （总结：定义、调用、相关）


      17.品牌管理：
        新增/修改/查询，品牌对象类型限制可复用。
        新增/修改接口返回也可以不限制类型
        类型复用的方式：内部使用/继承
        上传文件接口不用类型限制
        定义state返回值的类型  ( ):xx =>{}


      18.菜单路由权限：
        1.注意如果浅拷贝去过滤异步路由数组，会出现下次用户登录会丢失路由
        2.当在获取用户信息内添加路由时，在有权限的路由原地刷新会出现异步空白问题：还没加载完路由就访问。（解决方法，在守卫中，获取用户信息再next()，修改为next({...to})，确保目标个路由有再跳转）（注意）

      19.主题切换、暗黑模式切换：
        暗黑模式部分元素自适应背景
        部分元素跟随主题色
        持久化设置


      20.大屏
          1.大屏缩放本质是scale，保持比例铺满，利用屏幕与设计稿的比例差别，选最小方向的比例作为scale全方面的比例。

          2.水球图是在echarts官网外的拓展，可以在npm官网找到，需另外按照引入

          3.echarts-liquidfill@3 is compitable with echarts@5 
            echarts-liquidfill@2 is compitable with echarts@4
           （npm官网有说明兼容性）

          4.echarts进度条/比例图 没有现成的，需要利用柱状图重合，一条背景，一条内容,使用barGap为'-100%'。(不难)

          5.
            -title等配置项，里面的left/top等，可以设置百分百或者方位名词。
              （并且center可以绝对居中，50%不一定可以）

            -颜色类等配置项，可以使用常用的skyblue或者16进制。

              同时也可以配置渐变:
                  {
                        type: 'linear',
                        x: 0,
                        y: 0,
                        x2: 0,
                        y2: 1,
                        colorStops: [ {  //offset在此指的是y值
                            offset: 0, color: 'red' // 0% 处的颜色
                        },
                            {
                            offset: 0.5, color: 'orange' // 50% 处的颜色
                        },
                         {
                            offset: 1, color: 'white' // 100% 处的颜色
                        }],
                    }

          6.series可以决定图表的类型：
          
            柱状图中，可以一个对象设置所有柱子样式，柱子样式不同时，每个对象分别设置一个柱子样式即可。
            饼状图中，定义每段饼状的样式不同是通过series中的data配置项。

          7.地图组件最简配置

            import chinaJSON from '@/assets/data/china.json';
            //注册中国地图
            echarts.registerMap('china', chinaJSON as any)

            let mycharts = echarts.init(countryMap.value);
            mycharts.setOption({
                   //使用地图组件，geo里面还可以配置更多样式
                    geo:{
                        map:'china'
                    }
                })
          
          8.航线配置

          series:[
            {
                type:'lines',
                data:[  //每一个对象为一条线
                    {
                        coords:[ //坐标为起止点
                            [116.405285, 39.904989],  // 起点
                            [119.306239, 26.075302]   // 终点
                        ],
                       
                    }
                  ]
                }
            ]

          9.grid设置位置与大小无效的问题：

            -对表格类型效果明显，对饼状图和地图等无效（没有所谓的绘图网格）
             饼状图可设置series中的center和radius来代替控制位置和大小。
             地图可以通过geo下的top等调整位置，zoom/layoutCenter/layoutSize调整大小

            -可以通过外容器的padding代替


          10.雷达图：

          -基本结构搭建

            radar: {
              indicator: [
                  { name: '消费', max: 6500 },
                  { name: '好感', max: 16000 },
                  { name: '出行', max: 30000 },
                  { name: '小吃', max: 38000 },
                  { name: '爱好', max: 52000 },
                  { name: '景点', max: 25000 }
              ],
            }

          -添加点自动连线

              series: [
                        {
                            name: 'Budget vs spending',
                            type: 'radar',
                            data: [
                                {
                                    value: [4200, 3000, 20000, 35000, 50000, 18000],
                                    name: '购物'
                                },
                                {
                                    value: [5000, 14000, 28000, 26000, 42000, 21000],
                                    name: '吃饭'
                                }
                            ]
                        }
                    ]


          11.x轴刻度是否与x的标签对齐的问题：

              xAxis:{
                axisTick:{
                    alignWithLabel:true  //在折线图或散点图中对齐会更合理
                   },
                或者
                boundaryGap:false  //内容的左右区是否留白，调整后一般X轴刻度也会对齐标签；可以和上面配合使用，对齐同时左右不留白
               }


          12.柱状图/折线图遇到y轴默认有几条分割线加粗的问题，可能是1px带来的，可手动修改样式。
              yAxis: {
                splitLine:{
                    lineStyle:{
                        width:2,
                        opacity:0.3
                    }
                 }
                }

          13.柱子或者线条不同颜色：

          -若是多个大类的柱子设置不同颜色：（如果系列没有设置颜色，则会依次循环从该列表中取颜色作为系列颜色）
           option = {
            color:[
              '#94CCF4',
              '#BA94F4',
              '#94A4F4',
              '#F494C2',
            ],
              ...
           }
       
          -若是同一类的柱子在不同X值呈现不同颜色：

          series: [
            {
                type: 'bar',
                itemStyle: {
                    color:function(params){ //该对象可以得到seriesIndex, dataIndex, data, value 等各个参数。
                        //给每一个柱条这是背景颜色
                        let arr =['red','orange','yellowgreen','green','purple','hotpink','skyblue']
                         return arr[params.dataIndex];
                    }
                }
                ...
            }
          ]



      21.疫情业务开发

        1.登录模块：

          -rules规则中trigger如果是change，输入长度可动态变化，但是失去焦点时不会校验，解决方法：
            { min: 5, max: 10, message: '账号长度应为5-10位', trigger: ['blur','change'] },

          -滑动拼图验证：vue-puzzle-vcode，注意vue版本不同，安装与使用都有区别

            （还有vue3-slide-verify）

        2.封装分页、表格、工具

          - 提供的功能：只需引入分页、表格、工具栏(左增 导出等，右工具箱)、查询工具、el-popover确认操作，所有常规功能和基本数据，如分页数据..、查询、确认、增删改查api都在Crud对象中

          - 混入对象应该有的属性：表格数据、增删改查的总api对象、分页对象（默认总条数，当前条数，尺寸）、默认提示信息（四种）、主题名称、其它基本操作的功能方法
          （注意：1.混入对象的数据和方法，依赖的页面应该是自定义的表格组件，而不是业务页面
                 2.传入自定义配置对象，覆盖默认配置的属性值
            ）







自主分类笔记：


  element-plugs：

    1.在引入框架的Css后，:root选择器(可以理解成html标签)会带有默认的原生css变量，
    此时在vue项目页面中无法使用 根元素相关选择器 再去定义/重写任何原生Css变量，无论该变量是自定义还是框架的(特殊)

    2.覆盖框架自带的原生css变量：
      css：在页面中采用根选择器再去覆盖无效，应该在入口文件引入css文件覆盖(此时可以使用根选择器覆盖)。
      js:操作Dom的变量属性。

    3.覆盖默认暗黑颜色无效（未知）

    4.el-tree重新获取数据后，会不展开默认节点；页面切换再回来，也会不刷新树的展开。
    
    解决方法：node-key="id" ，通过给树节点添加key，官网有说明默认展开/选中需要设置该属性。

    5.el-table列宽的问题：
    
      -el-table-column同时设置min-width和width后，该列表格就会按照width来设置，相当于width就是一个最大宽度
      -el-table-column设置width=30%，无效。会被当成width=30px


    6. 树形表格可以使用el-table，也可以使用树形表格插件：vue-table-with-tree-grid。


    7. 解决el-row下的el-col高度不一致的问题  （不懂原理）

      无论如何修改el-row/el-col的样式都没有效，el-col的直接子元素设置style="height: 100%;"即可。



  Vue：

    -vue自带的鼠标右键方法：  v-on:contextmenu

    -vue中通过v-on给元素绑定事件，在事件中获取的this能否获取到触发元素?
      不能，原生js方法给DOM绑定事件，this可以获取到触发事件的DOM节点。而v-on给元素绑定事件，在vue2中，this为组件。vue3中this为undefiend。

      1.注意onclick直接绑定在标签上this是window
      2.onclick添加标签的形式在vue中使用会失效，因为this问题
      3.原生onclick后面需跟完整函数调用形式，如onclick="test()" 。
            

    -vue2、vue3中的事件参数一致：

      srcElement：可以获取data-xx自定义属性
      target：点击的具体节点
      currentTarget：事件触发的节点 （有时候控制打印会有点问题）

    -vue3中给自定义组件添加类名样式，只有在组件内有根节点才有效。（注意）

    -vue3中，watch检测中用到方法，且使用immediate:true，此时方法的声明需放在监听的前面。（因为setup里面本身就是函数执行）

    -hook 与 mixin （简单的说，提供data、method、生命周期供组件复用）
    
      hook：
        其实里面就是setup的内容，最后return是返回对象给页面接收后调用。
        hook里面无法直接获取vue组件实例ref()，vue组件里面定义的变量，也只能通过传参hook才能获取。(特殊，注意)

      mixin：
        vue2的混入返回对象，若定义时暴露的是函数，且有return对象，引入则可以传参mixins: [presenter()]。
                           若定义时暴露的是变量，引入则无法传参。

    -vue3中，reactive会丢失响应式的情况：

      1.直接赋值，整个对象替换了将不具备响应式（数组也会）。（可用isReactive(xxx)对比出）

        避坑办法：reactive直接包裹一个对象。

          let data=reactive({
              userData:{}        //里面定义一个对象，这样赋值就不会丢失响应式了。
          })
          data.userData=res.data  //将内层整个替换


      2.解构赋值reactive变量，获取会拿到旧的值，赋值的话该结果不会添加到响应式上。（即便解构的属性包含对象/数组）


      注意: 
            -页面的变量在丢失响应式后，便不会再响应式更新。(此时vue工具显示的也是旧的静态数据)
            -解构赋值后的都不会有响应式
            -无论数组/对象，用ref定义就不会有覆盖就没有响应式的问题，解构依然没有响应式


    -vue3中，自定义组件的ref属性不能和组件名一致，否则会报错(特殊)

    -Vue3中，已经不使用this和Vue.prototype，如何挂载全局的属性/方法，供全局调用：
    
      由于引入了组合式API和setup函数，this指向已经被废弃，而且也不再需要获取全局Vue实例。相反，Vue3提供了一个新的API globalProperties，可以用来在全局范围内注册属性和方法。


      方式一：(vue官网不推荐，getCurrentInstance官网已经查不到，隐式使用)
      
        1.main.js中挂载全局属性/方法：
          const app = createApp(App)
          app.config.globalProperties.xxx = xxx 
          app.mount('#app')

        2.页面中通过getCurrentInstance方法获取：

          <script setup>
            import { getCurrentInstance } from "vue"   // 引用 getCurrentInstance
            const { art } = getCurrentInstance().appContext.config.globalProperties
            let clicklogin = () => {
              art()         
            }
          </script>

          或者

          <script setup>
            import { getCurrentInstance } from "vue"
            const { proxy } = getCurrentInstance()    //获取 getCurrentInstance 身上的 proxy 代理属性
            let clicklogin = () => {
              proxy.art()           //可以直接在 proxy代理属性身上调用方法。
            }
          </script>


      方式二：

        1.main.js中暴露全局变量给后代
          const app = createApp(App)
          app.provide("xxx", xxx)    //通过provide暴露给后代实例
          app.mount('#app')

        2.页面中获取：
          <script setup>
          import { inject } from "vue"
          let xxx = inject("xxx")  
          </script> 


    - vue中，同一标签上不能同时使用v-for或者v-if，可以结合<template>标签。
     (v-if具有比 更高的优先级v-for。这意味着v-if条件将无法访问 范围内的变量v-for)

    - vue3中，如何判断父组件是否传了方法过来
        


  html+css：

    -样式穿透::v-deep使用并集选择器无效，但是可以嵌套
  
    --webkit-mask属性：（图片中透明的则代表不显示，不透明则表示显示）
      用于创建一个遮罩效果，遮罩效果可以创建非常复杂的形状，可以自定义颜色。
      优势：比背景颜色多了形态，比背景图片多了颜色设置
      一般配合 -webkit-mask-size: 100% 100%;

      注意webkit-mask会带来两个问题：自动给该元素overflow:hidden，同时该元素变为包含块。（有些场景会造成影响）

    -弹性容器开启子元素完全居中，但是子元素如果嵌套<span>标签。会导致垂直方向出现偏差：
       解决方法：span也添加垂直水平居中。

    -获取HTML根节点
        let html = document.documentElement;

    -原生Css变量也可以和样式一样覆盖。

    -容器display设置了inline-flex会使伪元素无法溢出。
    

  JS：

    -判断Blob二进制大文件对象类型：

     xxxx instanceof Blob

    -JS中调用的方法名存在动态变量，怎么如何调用？ （重要，动态属性也可以）
      1.若调用对象已知且可获取：通过对象.[]
      2.若调用对象已知/不确定，且不可获取：如vue3的setup中，无法获取实例对象this：
        eval(`change${index+1}(selectValue)`)
      注意：
        -在eval函数中直接拼接函数名调用，但是该方法只能在js用，在vue页面中拿不到window对象
        -若是动态属性，注意eval()要包裹整个赋值语句
        -原理：eval能解析代码块，也能将json转成js对象
        
  ts：

    return request<pageRes<infoItem>>({   //这里限制的是响应体返回的Data的结构
    ...
    })


